extends Control
class_name game
@warning_ignore("int_as_enum_without_cast") # typing nine main.types.null would be too long.
var board_data: Array[main.types] = \
[0, 0, 0, \
 0, 0, 0, \
 0, 0, 0]

const winning_lines = [
	[0,1,2], [3,4,5], [6,7,8], # horizontal
	[0,3,6], [1,4,7], [2,5,8], # vertical
	[0,4,8], [2,4,6]           # diagonal
]
var board_cells: Array[Cell]
var gameended: bool = false
var current_turn: main.types = main.types.CROSS

# Called when the node enters the scene tree for the first time.
func _ready() -> void:
	for i: Cell in $GridContainer.get_children():
		i.connect("clicked", _on_cell_clicked)
		board_cells.append(i)

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(_delta: float) -> void:
	pass

func _on_cell_clicked(cellid: int, playernum: int) -> void:
	if gameended:
		return
	if !main.localcoop and current_turn != main.PLAYER and playernum == 1:
		return
	if _set_type(cellid, current_turn) == false:
		return
	var winner: int =_check_winning_condition(board_data)
	if winner != -1:
		if winner == -2:
			print("draw")
		elif winner == 1:
			print("circle")
		elif winner == 2:
			print("cross")
		gameended = true
	
	if current_turn == main.PLAYER:
		if !main.localcoop:
			_set_turn(main.AI)
			_ai_turn()
		else:
			_set_turn(main.PLAYER2)
	else:
		_set_turn(main.PLAYER)

func _set_type(cellid: int, newtype: main.types) -> bool:
	var cell: Cell = $GridContainer.get_child(cellid - 1)
	
	if cell.type != main.types.NULL:
		main.print_warn(str(cell.name, " type is already not null, ignoring..."))
		return false
		
	if newtype == main.types.NULL:
		printerr("Null cannot be set as a type.") # might change later.
		
	cell.get_node("TextureRect").self_modulate = Color(1.0, 1.0, 1.0, 1.0)
	
	board_data.set(cellid - 1, newtype)
	
	if newtype == main.types.CROSS:
		cell.get_node("TextureRect").texture = cell.Cross
		cell.type = newtype
	elif newtype == main.types.CIRCLE:
		cell.get_node("TextureRect").texture = cell.Circle
		cell.type = newtype
	return true

func _set_turn(type: main.types) -> void:
	if !main.localcoop:
		if type != main.PLAYER:
			for i: Cell in board_cells:
				i.current_turn = main.types.NULL
		else:
			for i: Cell in board_cells:
				i.current_turn = type
	else:
		for i: Cell in board_cells:
			i.current_turn = type
	current_turn = type

func _check_winning_condition(board: Array) -> int:
	for line in winning_lines:
		var a = board[line[0]]
		var b = board[line[1]]
		var c = board[line[2]]
		if a != main.types.NULL and a == b and b == c:
			return a # winner
	if not board_data.has(main.types.NULL):
		return -2 # draw
	return -1 # nothing ever happens


func _ai_turn() -> void:
	print("ai_scary_stuff")
	#_on_cell_clicked(2, 2)
	var board_copy = board_data.duplicate()
	var best_score: int = int(-INF)
	var best_move_index: int = -1
	var possible_moves: Array
	
	for i in board_copy.size(): # find all possible moves
		if board_copy[i] == 0:
			possible_moves.append(i)
	
	for i in possible_moves:
		board_copy.set(i, main.AI)
		var score = minimax(false, board_copy, 0)
		print(score)
		board_copy.set(i, main.types.NULL)
		if score > best_score:
			best_score = score
			best_move_index = i
	if best_move_index != -1:
		_on_cell_clicked(best_move_index + 1, 2)
	else:
		printerr("AI Has not found any moves. This should NOT be possible.")
	print('asds')

func minimax(is_maxing: bool, board_copy: Array, depth: int) -> int:
	var winner: int = _check_winning_condition(board_copy)
	var max_eval: int = int(-INF)
	var min_eval: int = int(INF)
	if winner != -1:
		if winner == -2:
			return 0 # DRAW
		if winner == main.AI:
			return 10 - depth
		else:
			return -10 + depth

	var available_moves: Array
	for i in board_copy.size(): # find all possible moves
		if board_copy[i] == 0:
			available_moves.append(i)
	#print(depth)
	if is_maxing == true:
		for i in available_moves: # do every possible move in a board copy
			board_copy.set(i, main.AI)
			var eval = minimax(!is_maxing, board_copy, depth + 1)
			board_copy.set(i, main.types.NULL)
			max_eval = max(eval, max_eval)
		return(max_eval)
	else:
		for i in available_moves: # do every possible move in a board copy
			board_copy.set(i, main.PLAYER)
			var eval = minimax(!is_maxing, board_copy, depth + 1)
			board_copy.set(i, main.types.NULL)
			min_eval = min(eval, min_eval)
		return(min_eval)
