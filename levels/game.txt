extends Control
class_name game

const winning_lines = [
	[0,1,2], [3,4,5], [6,7,8], # horizontal
	[0,3,6], [1,4,7], [2,5,8], # vertical
	[0,4,8], [2,4,6]           # diagonal
]
var board_cells: Array[Cell]
var board_data: Array[main.types] = []
var gameended: bool = false
signal gameend(winner: main.WINTYPES)

var current_turn: main.types = main.PLAYER

@rpc("any_peer", "call_local", "reliable")
func _reset() -> void:
	board_data.fill(main.types.NULL)
	for i in board_cells:
		i.set_move(main.types.NULL)
		if main.gamemode != main.gamemodes.MULTIPLAYER:
			i.current_turn = main.PLAYER
	gameended = false
	if main.gamemode == main.gamemodes.MULTIPLAYER:
		if multiplayer.is_server():
			current_turn = main.PLAYER
		else:
			current_turn = main.PLAYER2
	else:
		current_turn = main.PLAYER
	$RestartPopUp.visible = false

func _ready() -> void:
	board_data.resize(9)
	board_data.fill(main.types.NULL)
	for i: Cell in $GridContainer.get_children():
		i.connect("clicked", _on_cell_clicked)
		board_cells.append(i)
	if main.gamemode == main.gamemodes.AI:
		if main.PLAYER == main.types.CIRCLE:
			_ai_turn()
	elif main.gamemode == main.gamemodes.MULTIPLAYER:
		if multiplayer.get_peers().size() <= 0 and multiplayer.is_server():
			$waitingforclient.visible = true
			await multiplayer.peer_connected
			$waitingforclient.visible = false
			if main.PLAYER == main.types.CROSS:
				_network_set_player.rpc_id(multiplayer.get_peers().get(0), main.types.CIRCLE, main.PLAYER)
			else:
				_network_set_player.rpc_id(multiplayer.get_peers().get(0), main.types.CROSS, main.PLAYER)
		online.connected = true

@rpc("any_peer", "reliable")
func _network_set_player(clientype: main.types, hostype: main.types) -> void:
	main.PLAYER = clientype
	main.PLAYER2 = hostype
	_set_current_turn(hostype)
	for i in board_cells:
		i.current_turn = clientype

func _on_cell_clicked(cellid: int) -> void:
	if gameended:
		return
	match main.gamemode:
		main.gamemodes.AI:
			if make_move(cellid, current_turn) == false:
				return
			current_turn = main.PLAYER2
			_ai_turn()
		main.gamemodes.MULTIPLAYER:
			if online.connected == false:
				return
			else:
				_validate_network_move(cellid, current_turn)
		main.gamemodes.LOCALMULTIPLAYER:
			if make_move(cellid, current_turn) == false:
				return
			if current_turn == main.PLAYER:
				_set_current_turn(main.PLAYER2)
			else:
				_set_current_turn(main.PLAYER)


func _set_current_turn(turn: main.types) -> void:
		current_turn = turn
		if main.gamemode != main.gamemodes.MULTIPLAYER:
			for i in board_cells:
				i.current_turn = turn


func make_move(cellid: int, type: main.types) -> bool:
	if gameended:
		return false
	var cell: Cell = board_cells[cellid - 1]
	if cell.type != main.types.NULL:
		main.print_warn(str(cell.name, " type is already not null, ignoring..."))
		return false
	if type == main.types.NULL:
		printerr("Null cannot be set as a type.") # safety stuff.
		return false
	board_data.set(cellid - 1, type)
	cell.set_move(type)
	_post_move()
	return true

func _validate_network_move(cellid: int, type: int) -> void: # client side validation but cmon, its tictactoe.
	print("ID: ", multiplayer.get_unique_id(), " | My Role: ", main.PLAYER, " | Current Turn: ", current_turn)
	if gameended:
		return
	if type == main.types.NULL:
		printerr("Null cannot be set as a type.") # safety stuff.
		return
	var cell: Cell = board_cells[cellid - 1]
	if cell.type != main.types.NULL:
		main.print_warn(str(cell.name, " type is already not null, ignoring..."))
		return
	if current_turn == main.PLAYER:
		print("ID: ", multiplayer.get_unique_id(), " | My Role: ", main.PLAYER, " | Current Turn: ", current_turn)
		_network_make_move.rpc(cellid, current_turn)

@rpc("any_peer", "call_local", "reliable")
func _network_make_move(cellid: int, type: int):
	var cell: Cell = board_cells[cellid - 1]
	board_data.set(cellid - 1, type)
	cell.set_move(type)
	_post_move()
	if current_turn == main.PLAYER:
		current_turn = main.PLAYER2
	else:
		current_turn = main.PLAYER

func _check_winning_condition(board: Array) -> main.WINTYPES:
	for line in winning_lines:
		var a = board[line[0]]
		var b = board[line[1]]
		var c = board[line[2]]
		if a != main.types.NULL and a == b and b == c:
			return a # winner
	if not board.has(main.types.NULL):
		return main.WINTYPES.DRAW # draw
	return main.WINTYPES.NULL # nothing ever happens

func _post_move() -> void:
	var winner = _check_winning_condition(board_data)
	if winner != main.WINTYPES.NULL:
		if winner == main.WINTYPES.DRAW:
			gameend.emit(main.WINTYPES.DRAW)
			print_debug("draw")
		elif winner == main.WINTYPES.CIRCLE:
			gameend.emit(main.WINTYPES.CIRCLE)
			print_debug("circle")
		elif winner == main.WINTYPES.CROSS:
			gameend.emit(main.WINTYPES.CROSS)
			print_debug("cross")
		gameended = true

func _ai_turn() -> void:
	if gameended:
		return
	var board_copy = board_data.duplicate()
	var best_score: int = -1000
	var best_moves: Array
	var possible_moves: Array
	const ALPHA: int = -1000
	const BETA: int = 1000
	
	for i in board_copy.size(): # find all possible moves
		if board_copy[i] == 0:
			possible_moves.append(i)
	
	for i in possible_moves:
		board_copy.set(i, main.PLAYER2)
		var score = minimax(false, board_copy, 0, ALPHA, BETA)
		board_copy.set(i, main.types.NULL)
		if score > best_score:
			best_score = score
			best_moves = [i]
		elif score == best_score:
			best_moves.append(i)
	print_debug(best_moves.size())
	if best_moves.size() > 0:
		var random_move = best_moves.pick_random()
		make_move(random_move + 1, main.PLAYER2)
		current_turn = main.PLAYER
	else:
		main.print_warn("AI Has not found any moves. This should NOT be possible.")

func minimax(is_maxing: bool, board_copy: Array, depth: int, alpha: int, beta: int) -> int:
	var winner: int = _check_winning_condition(board_copy)
	
	if winner != main.WINTYPES.NULL:
		if winner == main.WINTYPES.DRAW:
			return 0 # DRAW
		if winner == main.PLAYER2:
			return 10 - depth
		else:
			return -10 + depth

	var available_moves: Array
	for i in board_copy.size(): # find all possible moves
		if board_copy[i] == 0:
			available_moves.append(i)
	if main.beatableai == true and randi() % 10 == 1: # AI Crackâ„¢ to make it be able to lose.
		return(randi_range(-10, 10))
	if is_maxing == true:
		for i in available_moves: # do every possible move in a board copy
			board_copy.set(i, main.PLAYER2)
			var eval = minimax(!is_maxing, board_copy, depth + 1, alpha, beta)
			board_copy.set(i, main.types.NULL)
			alpha = max(eval, alpha)
			if beta <= alpha: # alpha beta shit optimization ig idk
				break
		return(alpha)
	else:
		for i in available_moves: # do every possible move in a board copy
			board_copy.set(i, main.PLAYER)
			var eval = minimax(!is_maxing, board_copy, depth + 1, alpha, beta)
			board_copy.set(i, main.types.NULL)
			beta = min(eval, beta)
			if beta <= alpha: # alpha beta shit optimization ig idk
				break
		return(beta)


func _on_button_pressed() -> void:
	if main.gamemode == main.gamemodes.MULTIPLAYER:
		_reset.rpc()
	else:
		_reset()
